package com.github.jtorleonstudios.generate.env.clazz;

import org.gradle.api.DefaultTask;
import org.gradle.api.GradleException;
import org.gradle.api.Project;
import org.gradle.api.provider.Property;
import org.gradle.api.tasks.SourceSet;
import org.gradle.api.tasks.SourceSetContainer;
import org.gradle.api.tasks.TaskAction;
import org.gradle.plugins.ide.idea.model.IdeaModel;
import org.jetbrains.annotations.NotNull;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

public class GenClassTask extends DefaultTask {
  public final static String GEN_PATH = "generated-src/main/java";

  public static void register(
    @NotNull Project project
  ) {
    // Register the task
    var task = project
      .getTasks()
      .register(
        "generateEnvClass",
        GenClassTask.class,
        v -> {
          v.setGroup("generateJava");
          v.setDescription("Generate Env Class");
        }
      );

    // Fired when compile java
    project
      .getTasks()
      .named("compileJava")
      .configure(v -> v.dependsOn(task));

    // Setup source set
    project
      .getExtensions()
      .getByType(SourceSetContainer.class)
      .named(
        SourceSet.MAIN_SOURCE_SET_NAME,
        sourceSet -> sourceSet
          .getJava()
          .srcDir(project
            .getLayout()
            .getBuildDirectory()
            .dir(GenClassTask.GEN_PATH)
          )
      );

    // Setup IDEA
    project
      .getPlugins()
      .withId(
        "idea",
        plugin -> project
          .getExtensions()
          .configure(
            IdeaModel.class,
            idea -> idea
              .getModule()
              .getGeneratedSourceDirs()
              .add(project
                .getLayout()
                .getBuildDirectory()
                .dir(GenClassTask.GEN_PATH)
                .get()
                .getAsFile()
              )
          )
      );
  }

  @TaskAction
  public void run() {
    var ext = getProject()
      .getExtensions()
      .getByType(GenClassExt.class);

    if (!GenClassExt.validate(ext)) {
      return; // should throw
    }

    var constants = ext.getConstants().getOrElse(Map.of());
    if (constants.isEmpty()) {
      return;
    }

    var outputPackage = ext.getOutputPackage().get().trim();

    var outputDirectory = createDirectory(outputPackage);

    var outputFileName = sanitizeObjectName(ext.getClassName()) +
                         sanitizeObjectName(ext.getClassSuffix());

    createFile(
      outputDirectory,
      outputFileName,
      generateClass(
        outputPackage,
        outputFileName,
        ext.getConstants().get()
      )
    );
  }

  private @NotNull File createDirectory(
    @NotNull String outputPackage
  ) {

    outputPackage = outputPackage.replace(".", "/");

    var outputDirectory = getProject()
      .getLayout()
      .getBuildDirectory()
      .dir(GEN_PATH + "/" + outputPackage)
      .get()
      .getAsFile();

    var resultMkDirs = outputDirectory.mkdirs();

    if (!resultMkDirs && !outputDirectory.exists()) {
      throw new GradleException(String.format(
        "Failed to generate output directory '%s'.%n" +
        "Possible reasons:%n" +
        " - Insufficient permissions to create directories%n" +
        " - A file with the same name already exists%n" +
        " - Path contains invalid characters%n%n" +
        "Please ensure that the path is writable and does not conflict with existing files.",
        outputDirectory.getAbsolutePath()
      ));
    }

    return outputDirectory;
  }

  private void createFile(
    @NotNull File outputDirectory,
    @NotNull String outputFileName,
    @NotNull List<String> lines
  ) {
    var file = new File(
      outputDirectory,
      outputFileName + ".java"
    );

    try (FileWriter writer = new FileWriter(file)) {
      writer.write(lines
        .stream()
        .collect(Collectors.joining(System.lineSeparator()))
      );
    } catch (IOException e) {
      getProject()
        .getLogger()
        .error(e.getMessage(), e);

      throw new GradleException(e.getMessage());
    }
  }

  private @NotNull List<String> generateClass(
    @NotNull String outputPackage,
    @NotNull String outputFileName,
    @NotNull Map<String, Object> mapConstants
  ) {
    var lines = new ArrayList<String>();

    outputPackage = outputPackage.toLowerCase();

    // Package
    lines.add("package " + outputPackage + ";");
    lines.add("");

    // Interface

    lines.add("/**");
    lines.add(" * <p>");
    lines.add(" * This {@code interface} is automatically generated by the Gradle plugin");
    lines.add(" *  {@code " + Main.PLUGIN_IDENTIFIER + "}.");
    lines.add(" * </p>");
    lines.add(" * <p>");
    lines.add(" * It contains environment constants defined in the {@code build.gradle} configuration.");
    lines.add(" *  <b>Do not edit this interface manually.</b> Any manual change will be lost when the ");
    lines.add(" *  source is regenerated.");
    lines.add(" * </p>");
    lines.add(" * <ul>");
    lines.add(" * <li>Generated by: {@code " + Main.PLUGIN_IDENTIFIER + "}</li>");
    lines.add(" * <li>Generation task: {@code " + GenClassTask.class.getName() + "}</li>");
    lines.add(" * <li>Output location: {@code build/" + GenClassTask.GEN_PATH + "/" + outputPackage.replace(".", "/") + "}</li>");
    lines.add(" * </ul>");
    lines.add(" *");
    lines.add(" * @author Jtorleon Studios Team");
    lines.add(" * @link <a href=\"https://github.com/jtorleon-studios-team\">https://github.com/jtorleon-studios-team</a>");
    lines.add(" */");
    lines.add("public interface " + outputFileName + " {");
    lines.add("");

    // Fields
    mapConstants.forEach((k, v) -> {
      var type = ConstantType.getType(v);
      switch (type) {
        case NULL -> getProject().getLogger().warn(
          "{}: constant '{}' is null and will be ignored. " +
          "Ensure that all constants in your 'envClass' extension are initialized.",
          Main.PLUGIN_IDENTIFIER,
          k
        );
        case OBJECT -> getProject().getLogger().warn(
          "{}: constant '{}' is of type Object, which is not supported by the plugin. " +
          "Only primitives (int, boolean, byte, short, long, float, double, char) and Strings are allowed.",
          Main.PLUGIN_IDENTIFIER,
          k
        );
        default -> {
          lines.add("  /**");
          lines.add("   * <p>");
          lines.add("   * Generated constant. Value is defined in the build configuration.");
          lines.add("   * </p>");
          lines.add("   * <ul>");
          lines.add("   * <li>Type: {@code " + type.getType() + "}</li>");
          lines.add("   * <li>Value: {@code " + v + "}</li>");
          lines.add("   * </ul>");
          lines.add("   */");
          lines.add(type.toCode(k, v));
          lines.add("");
        }
      }
    });

    lines.add("}");
    lines.add("");

    return lines;
  }

  private static String sanitizeObjectName(
    @NotNull Property<String> name
  ) {
    return Pattern
      .compile("^.")
      .matcher(name.get().trim())
      .replaceFirst(m -> m.group().toUpperCase());

  }

}
